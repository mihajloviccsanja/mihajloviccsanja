# -*- coding: UTF-8 -*-
import matplotlib.pyplot as plt
import numpy as np
import re
import cv2
import csv
from stl import mesh  
from matplotlib import cm
from matplotlib.ticker import LinearLocator
from scipy.spatial import Delaunay 


"""
Reads values of  function(x, y), where x and y ranges up to width, height dimensions of matrix in given .pfm file
"""
def read_pfm(pfm_file_path):
    with open(pfm_file_path, 'rb') as pfm_file:
        header = pfm_file.readline().decode().rstrip()
        channel = 3 if header == 'PF' else 0    #determining if given matrix is colored(3 channels) or in grayscale
 
        dim_match = re.match(r'^(\d+)\s(\d+)\s$', pfm_file.readline().decode('utf-8'))
        if dim_match:
            width, height = map(int, dim_match.groups())    #extracting dimensions from Match regex object
        else:
            raise Exception("Malformed PFM header.")
 
        scale = float(pfm_file.readline().decode().strip())
        if scale < 0:
            endian = '<'    #little endlian
            scale = -scale
        else:
            endian = '>'    #big endlian
 
        values = np.fromfile(pfm_file, endian + 'f')    #function values
        shape = (height, width, channel) if channel else (height, width)
        img = np.reshape(values, newshape=shape)
        img = np.flipud(img)    #arrange values in top to bottom order, since they should have been saved inversely

        return img, scale, height, width


"""
Helper class, since surface given in .pfm file has to be tesselated.
A, B, C are vertexes of a triangle, with [x, y, z] coordinates.
"""
class Triangle:
    def __init__(self):
        self.a= [0, 0, 0]
        self.b = [0, 0, 0]
        self.c = [0, 0, 0]


"""
Custom implementation of tesselation of given surface.

x and y are indices of matrix of desired size, 
over which is calculated function(x, y). Values of
function are z(x, y). 

Method for finding triangles on a surface is next:
-> in each segment  of matrix, alongside x and y axis, 
between adjacent (x, y) coordinates is square, which, divided
by arbitrary diagonal, gives 2 triangles in 2D plane.
-> When these triangles are projected onto given surface, triangles in 3D space,
which are onto surface of calulated function, are obtained.
"""
def extract_triangles(x, y, z):
    triangles = []
    for i in range(0, len(x)-1):    #len - 1 because squares in between coordinates are being obtained.
        for j in range(0, len(y)-1):
            tri = Triangle()
            tri.a = [i,j, z[i][j]]  #vertex of triangle
            tri.b = [i+1,j, z[i+1][j]]
            tri.c = [i,j+1, z[i][j+1]]
            triangles.append(tri)
            tri = Triangle()
            tri.a = [i+1,j+1, z[i+1][j+1]]
            tri.b = [i+1,j, z[i+1][j]]
            tri.c = [i,j+1, z[i][j+1]]
            triangles.append(tri)            
    return triangles

"""
Function which checks whether reading from .pfm file is done correctly by
comparing function values and matrix dimensions obtanied from it with the
ones saved directly in .csv file (which is generated by running generate_pfm.py) file.
"""
def pfm_test(height, width, img):
    z_check = []

    with open('coordinates.csv', newline='') as csvfile:    #reading raw values of chosen function, saved in given .csv file
        reader = csv.DictReader(csvfile)
        row1 = next(reader)
        height_check = int(row1['height'])
        width_check = int(row1['width'])
        for row in reader:
            z_check.append(np.float32(row['z']))
    z_check = np.array(z_check)
    z_check = np.reshape(z_check,  newshape=(height_check,width_check ) )

    if height_check!=height:    #comparing read values of matrix dimensions and function values with the ones extracted from .pfm file
        raise Exception('written and read heights in pfm file do not match')

    if width_check!=width:
        raise Exception('written and read widths in pfm file do not match')

 
    if not np.array_equal(z_check, img):
        raise Exception('written and read images in pfm file do not match')

"""
Function which writes tesselates surface (extracted triangles) in .stl file format.
"""
def triangles2stl(triangles):

    data = np.zeros(len(triangles), dtype=mesh.Mesh.dtype)
    generated_triangles = np.zeros((len(triangles), 3, 3))
    for i in range(len(triangles)):
        data["vectors"][i] = np.array([triangles[i].a, triangles[i].b, triangles[i].c])
        generated_triangles[i] = np.array([triangles[i].a, triangles[i].b, triangles[i].c])
    m=mesh.Mesh(data)
    m.save('extracted_triangles.stl')
    return generated_triangles

"""
3D graphical representation of function obtained from .pfm file.
Can serve as visual check of correct reading from file by comparing it
with graphical representation of function in generate_pfm.py.
Also, can serve as baseground for what should tesselated surface look like.
"""
def plot_surface_from_pfm(X, Y, img):
    X, Y = np.meshgrid(X, Y)

    # Plot the surface.
    fig, ax = plt.subplots(subplot_kw={"projection": "3d"})
    surf = ax.plot_surface(X, Y, img, cmap=cm.coolwarm, linewidth=0, antialiased=False)

    # Customize the z axis.
    #ax.set_zlim(-1.01, 1.01)
    ax.zaxis.set_major_locator(LinearLocator(10))
    # A StrMethodFormatter is used automatically
    ax.zaxis.set_major_formatter('{x:.02f}')

    # Add a color bar which maps values to colors.
    fig.colorbar(surf, shrink=0.5, aspect=5)    

    plt.show()

"""
Since some quantitative way of determining whether 
surface tesselation is done right is needed, 
2D Delaunay triangulation method's implementation is
used ase a "golden model" against which customly generated
triangles are checked. (https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Delaunay.html)
2D Delaunay triangulation basically does the same thing as implemented function.

(Side note - 3D Delaunay triangulation was also used for checking. It deliveres tetrahedrons. Unique triangles of
these tetrahedrons were isolated, since those which are duplicated etc are supposed to be on the "inside" of the function, 
so the unique ones should represent surface. But results didn't seem to be correct, so this method is ommited.)

"""
def extract_triangles_test(height, width, img):
    vertices = []

    for x in range(0, height):
        for y in range(0, width):
            vertices.append([x, y])  #vertices of triangles

    tri = Delaunay(vertices)
    num_triangles=len(tri.simplices)    #simplices represent triangles, by listing it's vertices

    data = np.zeros(num_triangles, dtype=mesh.Mesh.dtype)
    test_triangles = np.zeros((num_triangles, 3, 3))    #used for comparing with triangles obtained from implemented function
    for i in range(num_triangles):

        xa = vertices[tri.simplices[i, 0]][0]   #coordinates of vertices of a triangle
        ya = vertices[tri.simplices[i, 0]][1]
        za = img[xa][ya]    #value of func(x, y)

        xb = vertices[tri.simplices[i, 1]][0]
        yb = vertices[tri.simplices[i, 1]][1]
        zb = img[xb][yb]

        xc = vertices[tri.simplices[i, 2]][0]
        yc = vertices[tri.simplices[i, 2]][1]
        zc = img[xc][yc]

        tri.a = [xa, ya, za]
        tri.b = [xb, yb, zb]
        tri.c = [xc, yc, zc]
        new_triangle = np.array([tri.a, tri.b, tri.c])
        data["vectors"][i] = new_triangle
        test_triangles[i] = new_triangle
    
    m=mesh.Mesh(data)
    m.save('test_triangles.stl')
    return test_triangles
"""
Way of checking if implemented function works as expected.
"""
def compare_triangles(generated_triangles, test_triangles):
    if  not (len(generated_triangles)==len(test_triangles)):
        raise Exception('number of found and test triangles is not the same!')

    for i in range(0, len(generated_triangles)):
        if not (generated_triangles[i] in test_triangles):  #since order of triangles/vertices can be different in these arrays
            raise Exception('triangles do not match')


def main():
    pfm_file ='demofile.pfm'
    img, scale, height, width = read_pfm(pfm_file)
    img = img*scale
    pfm_test(height, width, img)
    X = np.arange(0, height, 1)
    Y = np.arange(0, width, 1)

    triangles = extract_triangles(X, Y, img)

    generated_triangles = triangles2stl(triangles)

    test_triangles = extract_triangles_test(height, width, img)

    compare_triangles(generated_triangles, test_triangles)


    plot_surface_from_pfm(X, Y, img)

if __name__ == '__main__':
    main()